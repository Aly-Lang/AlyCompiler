#include <codegen.h>

#include <error.h>
#include <environment.h>
#include <parser.h>
#include <stdio.h>
#include <string.h>

// TODO: Add version number ???
const char* codegen_header = "This file was generated by the AlyCompiler";

unsigned int fwrite_line(char* bytestring, FILE* file) {
    size_t length = strlen(bytestring);
    unsigned int status = fwrite(bytestring, 1, length, file);
    if (status != 0) { return status; }
    return fwrite("\n", 1, 1, file);
}

unsigned int fwrite_bytes(char* bytestring, FILE* file) {
    size_t length = strlen(bytestring);
    return fwrite(bytestring, 1, length, file);
}

Error codegen_program_x86_64_att_asm(ParsingContext* context, Node* program) {
    Error err = ok;
    if (!program || program->type != NODE_TYPE_PROGRAM) {
        ERROR_PREP(err, ERROR_ARGUMENTS, "codegen_program() requires a a program!");
        return err;
    }

    FILE* code = fopen("code.S", "wb");
    if (!code) {
        ERROR_PREP(err, ERROR_GENERIC, "codegen_program() could not open code file");
        return err;
    }
    
    fwrite_bytes(";#; ", code);
    fwrite_line((char*)codegen_header, code);
    
    // TODO: Generate code :^)

    // TODO: Allocate `.space` for all global variable declarations.

    Node* expression = program->children;
    Node* tmpnode1 = node_allocate();
    while (expression) {
        switch (expression->type) {
        default:
            break;
        case NODE_TYPE_VARIABLE_DECLARATION:
            // TODO: Get size of type, generate `<identifier>: .space <size>` directive.
            //       We also need to keep track of identifier somehow.

            // Get type symbol ID of variable from variables context using 
            // variable symbol ID.
            environment_get(*context->variables, expression->children, tmpnode1);
            // Get type info of type from type context using type symbol ID.
            environment_get(*context->types, tmpnode1, tmpnode1);

            fwrite_bytes("", code);

            print_node(tmpnode1, 0);
            // TODO: Handle nested scopes (stack based variables).
            break;
        }

        expression = expression->next_child;
    }

    fclose(code);
    return ok;
}

Error codegen_program(CodegenOutputFormat format, ParsingContext* context, Node* program) {
    if (!context) {
        ERROR_CREATE(err, ERROR_GENERIC, "codegen_program() must be passed a non-NULL context!");
        return err;
    }
    switch (format) {
    case OUTPUT_FMT_DEFAULT:
    case OUTPUT_FMT_x86_64_AT_T_ASM:
        return codegen_program_x86_64_att_asm(context, program);
        break;
    }
    return ok;
}